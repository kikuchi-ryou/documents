# Chapter1. ドメイン駆動設計とは

- 知識をコードに埋め込むことを実現するための手法
- ソフトウェア開発におけるドメインは「プログラムを適用する対象となる領域」を指す
  - 例）会計システムであれば金銭や帳票、物流システムであれば貨物や倉庫や輸送手段

### 1.2.1 ドメインモデルとは何か

- 現実の事象あるいは概念を抽象化したもの
  - 現実を全て再現するわけではない
  - 何を取捨選択するかはドメインによる
    - 例）ペンの場合、小説家ならば文字を書くこと。文房具店であれば値段や在庫など。何に重きを置くかは異なる。

### 1.2.2 知識をコードで表現するドメインオブジェクト

- ドメインモデルをソフトウェアで動作するモジュールとして表現したもの
- ドメインオブジェクトはドメインモデルの実装表現
  - ドメインの変化は、ドメインモデルを媒介にして連鎖的にドメインモデルまで伝わる

## 1.4 本書で解説するパターンについて

- 知識を表現するパターン
  - 値オブジェクト
  - エンティティ
  - ドメインサービス
- アプリケーションを表現するためのパターン
  - リポジトリ
  - アプリケーションサービス
  - ファクトリ
- 知識を表現、より発展的なパターン
  - 集約
  - 仕様

# Chapter2. システム固有の値を表現する「値オブジェクト」

## 2.2 値の性質と値オブジェクトの実装

- 代表的な値の性質
  - 不変である
  - 交換が可能である
  - 等価性によって比較される

### 2.2.1 不変である

- 値の変更をするときは代入を利用
  - 厳密には値の変更はしていない
    - 値が変更できてしまうと、安心して値を利用できない

```c#
// 一般的に見られる値の変更(NG)
var fullName = new FullName("masanobu", "naruse");
fullName.ChangeLastName("sato");
```

- FullName はシステム固有の値を表している値オブジェクト
  - 不変にすべき
  - ChangeLastName メソッドは FullName クラスに定義されるべきでない

### 2.2.2 交換可能である

- 「不変」の性質を持つ値は変更できない
  - 代入操作によって交換することで表現

```c#
// 値オブジェクトの変更方法
var fullName = new FullName("masanobu", "naruse");
fullName = new FullName("masanobu", "sato");
```

### 2.2.3 等価性によって比較される

- 値オブジェクトはあくまで値で、システム固有の値
  - その属性を取り出して比較するのはNG
    - 値オブジェクト同士で比較するようにする方が自然
    - 属性が追加されても修正が一箇所で済む

```c#
using System;

// 比較メソッドを提供するFullNameクラス
class FullName : IEquatable<FullName>
{
    public string FirstName{get;}
    public string LastName{get;}
    
    public FullName(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }
    
    public bool Equals(FullName other)
    {
        if (ReferenceEquals(null, other))
            return false;
        if (ReferenceEquals(this, other))
            return true;
            
        return string.Equals(FirstName, other.FirstName) && string.Equals(LastName, other.LastName);
        // もしミドルネームが追加されてもここだけ修正すればOK
    }
    
    public override bool Equals(object obj)
    {
        if (ReferenceEquals(null, obj))
            return false;
        if (ReferenceEquals(this, obj))
            return true;
        if (obj.GetType() != this.GetType())
            return false;
            
        return Equals((FullName), obj);
    }
    
    // Equalsをoverrideする際にはGetHashCodeをoverrideするルールがある
    public override int GetHashCode()
    {
        unchecked
        {
            return ((FirstName != null ? FirstName.GetHashCode() : 0 * 397)) ^ (LastName != null ? LastName.GetHashCode() : 0);
        }
    }
}
```

## 2.3 値オブジェクトにする基準

- （筆者の考え）「そこにルールが存在しているか」と「それ単体で取り扱いたいか」
- 重要なのは値オブジェクトにすべきか見極めて、そうすべきと判断したら大胆に実行

## 2.4 ふるまいをもった値オブジェクト

- 独自の振る舞いを定義できる
- 例）お金オブジェクトに加算するメソッドを実装
  - お金を加算するときは通貨単位を揃える必要があるので、加算する前に同一通貨か確認する
  - 仮に乗算が定義されていなければ、暗にそれができないことを示している

## 2.5 値オブジェクトを採用するモチベーション

- 表現力を増す
  - 例）製品番号が「プロダクトコード＋枝番＋ロット番号」で構成されていることを伝えることができる
- 不正な値を存在させない
- 誤った代入を防ぐ
- ロジックの散在を防ぐ
